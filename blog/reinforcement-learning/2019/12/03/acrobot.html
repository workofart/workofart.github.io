<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>OpenAI Gym - Acrobot-v1 | Henry’s Blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="OpenAI Gym - Acrobot-v1" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Code" />
<meta property="og:description" content="Code" />
<link rel="canonical" href="http://henrypan.com/blog/reinforcement-learning/2019/12/03/acrobot.html" />
<meta property="og:url" content="http://henrypan.com/blog/reinforcement-learning/2019/12/03/acrobot.html" />
<meta property="og:site_name" content="Henry’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-03T16:00:00-05:00" />
<script type="application/ld+json">
{"url":"http://henrypan.com/blog/reinforcement-learning/2019/12/03/acrobot.html","headline":"OpenAI Gym - Acrobot-v1","datePublished":"2019-12-03T16:00:00-05:00","dateModified":"2019-12-03T16:00:00-05:00","description":"Code","mainEntityOfPage":{"@type":"WebPage","@id":"http://henrypan.com/blog/reinforcement-learning/2019/12/03/acrobot.html"},"@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://henrypan.com/blog/feed.xml" title="Henry's Blog" /></head>
<body><header class="site-header" role="banner">
    <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Henry&#39;s Blog</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger">
            <a class="page-link" href="http://henrypan.com">Homepage</a>
            <!---->
          </div>
        </nav></div>
  </header>
  <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">OpenAI Gym - Acrobot-v1</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-12-03T16:00:00-05:00" itemprop="datePublished">Dec 3, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="code">Code</h2>

<p><a href="https://github.com/workofart/openai-gym-baselines/tree/master/Acrobot-v1">Here</a></p>

<h2 id="1-goal">1. Goal</h2>
<p>The problem setting is to solve the <a href="https://gym.openai.com/envs/Acrobot-v1/">Acrobot</a> problem in OpenAI gym. The acrobot system includes two joints and two links, where the joint between the two links is actuated. Initially, the links are hanging downwards, and the goal is to swing the end of the lower link up to a given height (<em>the black horizontal line</em>)</p>

<p><img src="https://github.com/workofart/openai-gym-baselines/raw/master/Acrobot-v1/test-run.gif" alt="test-run" style="zoom: 67%;" /></p>

<p><br /></p>

<h2 id="2-environment">2. Environment</h2>
<p>The acrobot environment has a continuous state space as follows (copied from <a href="https://github.com/rlpy/rlpy/blob/master/rlpy/Domains/Acrobot.py">source code comments</a>):</p>

<h3 id="state">State:</h3>

<p>The state consists of the sin() and cos() of the two rotational joint angles and the joint angular velocities :</p>

<script type="math/tex; mode=display">[\cos(\theta_1), \sin(\theta_1), \cos(\theta_2), \sin(\theta_2), v_1,v_2]</script>

<p>For the first link, an angle of 0 corresponds to the link pointing downwards. The angle of the second link is relative to the angle of the first link.</p>

<p>For example:</p>

<ul>
  <li>an angle of 0 corresponds to having the same angle between the two links.</li>
  <li>a state of [1, 0, 1, 0, …, …] means that both links point downwards.</li>
</ul>

<h3 id="action">Action:</h3>

<p>The action is either applying <code class="highlighter-rouge">+1</code>, <code class="highlighter-rouge">0</code> or <code class="highlighter-rouge">-1</code> torque on the joint between the two pendulum links.</p>

<h3 id="reward">Reward:</h3>

<p>At each timestep (not episode), the reward is set to be -1 if the lower end never reaches the horizontal ruler, and 0 if it has.</p>

<h3 id="terminal-condition">Terminal Condition:</h3>

<p>The environment imposes a 500 timestep limit to each episode, which means after 500 timesteps, if the pole still hasn’t reached the goal, the episode will terminate and reset.</p>

<h3 id="solved-condition">Solved Condition:</h3>

<p>There are no specific requirements, see the <strong>experiments section</strong> for a comparison of performance with the leaderboard.</p>

<p><br /></p>

<h2 id="3-approach">3. Approach</h2>

<h3 id="31-algorithm-comparison">3.1 Algorithm Comparison</h3>

<p>I chose to use <em>actor-critic</em> with state-value temporal difference (TD) to train an on-policy agent. I assumed an infinite time horizon when deciding on the algorithm, since this problem requires the agent to build momentum to actually swing up to the top, which means the policy can’t be short-sighted and needs to consider all the actions it took to build momentum and finally reach the goal.</p>

<p><strong>Key considerations:</strong></p>
<ul>
  <li>The state space is continuous, it would be inefficient to represent the state-action values (q-values) in traditional tabular form.</li>
  <li>This problem does not require a global optimal solution, we consider the problem solved after reaching a reward of larger than -100. This means that we can trade-off the accuracy of the algorithm in exchange for a more efficient training process while still finding a near-global optimal policy.</li>
  <li>Dense rewards. There is no final reward, rather the reward is given at every time step, and represents how far/close the agent is from the goal, so the feedback is very “real-time”.</li>
  <li>If the problem is using an on-policy algorithm, then we should consider adding temporal difference (baseline) to reduce the variance of the gradient estimation while ensuring the bias is not increased.</li>
</ul>

<p><br /></p>

<h3 id="32-problem-parameterization">3.2 Problem Parameterization</h3>

<p>I initially started with simple radial-basis functions with 10 centers for each of the state dimensions, which resulted in <script type="math/tex">10^6</script> size state space. This drastically slowed down the training of my agent and the progress of this project, so I switched to use a neural network to parameterize both the value function and policy function.</p>

<p><strong>Key considerations:</strong></p>

<p>Since this problem is in a continuous space, I had to use a function approximator to approximate the state space which can then be used to train the agent.</p>

<p><br /></p>

<h3 id="33-policy">3.3 Policy</h3>

<p>I initially attempted to use a Gaussian function with varying <script type="math/tex">\sigma</script>, but it was very inefficient and ineffective to hand-tweak the <script type="math/tex">\sigma</script> and parameterize the Gaussian mean, so I eventually resorted to a neural network.</p>

<h4 id="key-consideration">Key consideration:</h4>

<p>The relationship between actions and state space is non-linear</p>

<p><br /></p>

<h3 id="34-neural-network-architecture">3.4 Neural Network Architecture</h3>

<p>By incorporating the Rectified-Linear unit (ReLU) activation function, we can represent the non-linear relationship between the state space, the policy, and the value of that state. Please refer to <strong>[4.3 Neural Network Complexity]</strong> section for the reasoning behind the number of neurons.</p>

<p><img src="/blog/assets/images/rl/acrobot_actor_nn.png" alt="actor_NN" /></p>

<center><b>Actor Neural Network</b></center>

<p><br /></p>

<p><img src="/blog/assets/images/rl/acrobot_critic_nn.png" alt="critic_NN" /></p>

<center><b>Critic Neural Network</b></center>

<p><br /></p>

<h3 id="35-hyperparameters">3.5 Hyperparameters</h3>

<ul>
  <li><strong>Actor’s (Policy) Learning Rate (<script type="math/tex">\alpha_{a}</script>):</strong> <script type="math/tex">1 \times 10^{-4}</script></li>
  <li><strong>Critic’s (Value) Learning Rate (<script type="math/tex">\alpha_{c}</script>):</strong> <script type="math/tex">5 \times 10^{-3}</script></li>
  <li><strong>Discount Rate (<script type="math/tex">\gamma</script>):</strong> 0.9</li>
  <li><strong>Neural Network Weight Initialization:</strong> Normal Distribution with zero mean and 0.1 standard deviation</li>
  <li><strong>Neural Network Bias Initialization:</strong> 0.1 constant</li>
  <li>128/64 Neurons in the first/second hidden layer respectively for both the policy network and the value network</li>
</ul>

<p><br /></p>

<h2 id="4-experiment--findings">4. Experiment &amp; Findings</h2>

<h3 id="41-performance">4.1 Performance</h3>

<table>
  <thead>
    <tr>
      <th>User</th>
      <th>Best 100-episode performance</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>mallochio</td>
      <td>-42.37 ± 4.83</td>
    </tr>
    <tr>
      <td>marunowskia</td>
      <td>-59.31 ± 1.23</td>
    </tr>
    <tr>
      <td>MontrealAI</td>
      <td>-60.82 ± 0.06</td>
    </tr>
    <tr>
      <td><a href="https://github.com/Bhaney44">BS Haney</a></td>
      <td>-61.8</td>
    </tr>
    <tr>
      <td><a href="https://github.com/FelixNica">Felix Nica</a></td>
      <td>-63.13 ± 2.65</td>
    </tr>
    <tr>
      <td>Daniel Barbosa</td>
      <td>-67.18</td>
    </tr>
    <tr>
      <td><a href="https://gihub.com/khordoo">Mahmood Khordoo</a></td>
      <td>-68.63</td>
    </tr>
    <tr>
      <td>lirnli</td>
      <td>-72.09 ± 1.15</td>
    </tr>
    <tr>
      <td><a href="https://github.com/Tiger767">Tiger37</a></td>
      <td>-74.49 ± 10.87</td>
    </tr>
    <tr>
      <td>tsdaemon</td>
      <td>-77.87 ± 1.54</td>
    </tr>
    <tr>
      <td>a7b23</td>
      <td>-80.68 ± 1.18</td>
    </tr>
    <tr>
      <td>DaveLeongSingapore</td>
      <td>-84.02 ± 1.46</td>
    </tr>
    <tr>
      <td>Sanket Thakur</td>
      <td>-89.29</td>
    </tr>
    <tr>
      <td>loicmarie</td>
      <td>-99.18 ± 2.60</td>
    </tr>
    <tr>
      <td>simonoso</td>
      <td>-113.66 ± 5.15</td>
    </tr>
    <tr>
      <td>alebac</td>
      <td>-427.26 ± 15.02</td>
    </tr>
    <tr>
      <td>mehdimerai</td>
      <td>-500.00 ± 0.00</td>
    </tr>
  </tbody>
</table>

<p>Compared to the  leaderboard, our last 100 episode (total 1000 episodes) average reward is <strong>-74.9</strong>, with raw rewards below:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EP[150]: -275.0
EP[160]: -231.0
EP[170]: -243.0
EP[180]: -209.0
EP[190]: -277.0
EP[200]: -268.0
EP[210]: -357.0
EP[220]: -115.0
EP[230]: -101.0
EP[240]: -98.0
EP[250]: -141.0
EP[260]: -86.0
...
EP[910]: -83.0
EP[920]: -77.0
EP[930]: -70.0
EP[940]: -80.0
EP[950]: -80.0
EP[960]: -132.0
EP[980]: -82.0
EP[990]: -76.0
EP[1000]: -69.0
</code></pre></div></div>

<p>This shows that with a baseline agent, with only a simple 2-layer neural network to approximate the policy and value functions, the performance is relatively good (about average on the leaderboard). The agent is also able to reach &gt; -200 rewards at around 220 episodes and convergences to &gt; -100 rewards after 240 episodes. The next section will depict the reward/episode relationship, which shows the fast convergence of this algorithm.</p>

<p><br /></p>

<h3 id="42-training-duration">4.2 Training Duration</h3>

<p><img src="/blog/assets/images/rl/acrobot_rewards_1000EP_128_64.png" alt="acrobot_rewards_1000EP_128_64" /></p>

<p><img src="/blog/assets/images/rl/acrobot_rewards_500EP_128_64.png" alt="acrobot_rewards_500EP_128_64" /></p>

<table>
  <thead>
    <tr>
      <th># Episodes</th>
      <th>Training Time</th>
      <th>Avg Reward (last 100 episodes)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000</td>
      <td>404 seconds</td>
      <td>-74.9</td>
    </tr>
    <tr>
      <td>500</td>
      <td>256 seconds</td>
      <td>-82.3</td>
    </tr>
    <tr>
      <td>250</td>
      <td>151 seconds</td>
      <td>-90.5</td>
    </tr>
  </tbody>
</table>

<p>We can see that even with 500 episodes of training, the agent is able to converge to &gt; -100 rewards at around 60 episodes. The table shows that, with this approach, training for 500 episodes is sufficient for a baseline performance, and further training has only marginal gains in terms of improving average reward. Perhaps, this shows that performance <em>could be</em> bottlenecked by our simple 2-layer neural network’s function approximation ability.</p>

<p><br /></p>

<h3 id="43-neural-network-complexity">4.3 Neural Network Complexity</h3>

<p><img src="/blog/assets/images/rl/acrobot_rewards_1000EP_32_16.png" alt="acrobot_rewards_1000EP_32_16" /></p>

<center><b>16/32 Neurons</b></center>
<p><br /></p>

<p><img src="/blog/assets/images/rl/acrobot_rewards_1000EP_128_64.png" alt="acrobot_rewards_1000EP_128_64" /></p>

<center><b>64/128 Neurons</b></center>
<p><br /></p>

<p><img src="/blog/assets/images/rl/acrobot_rewards_1000EP_256_128.png" alt="acrobot_rewards_1000EP_256_128" /></p>

<center><b>128/256 Neurons</b></center>
<p><br /></p>

<p>If we have too many neurons per layer, it will likely to overfit the function, whether that’s the value function or the policy. Translated into rewards, the neural network will try to learn a more complex value function and policy, where in reality, the “true” function is not that complex, resulting in the agent taking worse actions, and leading to the big gaps and unstable rewards, shown in in the 128/256 neuron case. If we have too few neurons, such as 32 and 16 in layer1 and layer2 respectively, the neural network will not be complex enough to approximate the value function and the policy, which is reflected in the first plot, showing slower learning and more variance in the reward/episode. The best number of neurons is 128 and 64 in layer1 and layer2 respectively, shown in the second plot.</p>

<p><br /></p>

<h3 id="44-discount-rate">4.4 Discount Rate</h3>

<p><strong>No Discount Rate</strong>
<img src="/blog/assets/images/rl/acrobot_rewards_1000EP_128_64_no_discount.png" alt="acrobot_rewards_1000EP_128_64_no_discount" /></p>

<p><br /></p>

<p><strong>With Discount Rate</strong>
<img src="/blog/assets/images/rl/acrobot_rewards_1000EP_128_64.png" alt="acrobot_rewards_1000EP_128_64" /></p>

<p>Since I assumed the algorithm to be operating in infinite time horizon, adding in a discount rate helps with the reward estimation. Intuitively, the task of reaching the goal can be accomplished within a couple of timesteps, but during the training process, the agent will accumulate a lot of failed attempts in building momentum. Without a discount rate, these failed attempts will be will be equally weighted when computing the value for this episode.</p>

<p><br /></p>

<h2 id="5-next-steps">5. Next Steps</h2>

<p>Since we’re using a simple neural network to represent both the policy and value function for our actor-critic algorithm, there could be potential improvements if we increase the complexity of these networks. Perhaps, with a more complex non-linear function approximator, there could be improvement in performance. At the same time, training for a longer period might be necessary to fully adjust the weights of the neural network.</p>

<p>It is always a good thing to try out other value functions such as deep Q-learning, combined with the actor-critic approach.</p>


  </div><a class="u-url" href="/blog/reinforcement-learning/2019/12/03/acrobot.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Henry&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Henry&#39;s Blog</li><li><a class="u-email" href="mailto:hanxiangp@gmail.com">hanxiangp@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/workofart"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">workofart</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My learning notes, research, projects and musings.</p>
      </div>
    </div>

  </div>

</footer>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </body>

</html>
